# Servidor Startup - PIXIE

## Tabla de contenidos
1. [Introducción](#introducción)
2. [Descripción básica del Sistema](#descripción-básica-del-sistema)
    1. [Configuración inicial del sistema](#configuración-inicial-del-sistema)
    2. [Grupos de trabajo](#grupos-de-trabajo)
    3. [Reporte del login del administrador](#reporte-del-login-del-administrador)
    4. [Copias de seguridad](#copias-de-seguridad)
    5. [Copias de seguridad remotas](#copias-de-seguridad-remotas)
    6. [Tripwire](#tripwire)
    7. [Ficheros CRON](#ficheros-cron)
    8. [Particiones y cuotas](#particiones-y-cuotas)
        1. [Sistema de ficheros /mnt/home](#aistema-de-ficheros-/mnt/home)
        2. [Aplicar cuotas](#aplicar-cuotas)
    11. [Configurar CGI](#configurar-cgi)
    12. [Ficheros log](#ficheros-log)
3. [Descripción básica de los servidores](#descripción-básica-de-los-servidores)
    1. [SSH](#ssh)
    2. [Apache2](#apache2)
    3. [Introducción](#_Toc9623173)
    4. [Instalación Apache2](#_Toc9623174)
    5. [Habilitar fichero .htaccess](#_Toc9623175)
    6. [Mover HTML](#_Toc9623176)
    7. [Protección anti-ataques DoS](#_Toc9623177)
    8. [Página segura HTTPS con SSL-RSA](#_Toc9623178)
    9. [AWStats](#_Toc9623179)
    10. [MariaDB](#_Toc9623180)
    11. [Creación de Blogs](#_Toc9623181)
    12. [Cacti](#_Toc9623182)
    13. [Servidor de correo electrónico (Roundcube)](#_Toc9623183)
    14. [Servidor FTP](#_Toc9623184)
4. [Explicación scripts CGI](#_Toc9623185)
    1. [Problemas encontrados](#_Toc9623186)
    2. [Posibles mejoras](#_Toc9623187)
    3. [Conclusiones](#_Toc9623188)
5. [Referencias](#_Toc9623189)

## 1. Introducción
La siguiente práctica consistirá en hacer un servidor web para una pequeña startup, como se indica en el enunciado que podremos encontrar en Studium. Nuestro enfoque ha sido hacia una tienda de E-commerce y en concreto de venta de ropa.

Cabe destacar que la plantilla html la hemos descargado ya que era gratuita y la hemos modificado con nuestras necesidades.

Veamos algunas imágenes del sitio web que hemos creado:

![img01](assets/img01.png?raw=true "img01")

![img02](assets/img02.png?raw=true "img02")

![img03](assets/img03.png?raw=true "img03")

![img04](assets/img04.png?raw=true "img04")

## 2. Descripción básica del Sistema

Lo primero que tenemos que conocer, antes de entrar en detalle de la descripción básica del sistema, es conocer el sistema operativo donde vamos a realizar la práctica.
Para la realización de la práctica se han usado tanto las distribuciones debian instaladas en el laboratorio de informática como Ubuntu para poder utilizarlo desde casa. En nuestro caso hemos usado *Ubuntu 18.04.2*.

### 2.1. Configuración inicial del sistema

Primero debemos actualizar el sistema e instalar algunos módulos que necesitaremos más adelante. Para actualizar el sistema:

```
apt-get update
apt-get upgrade
```
Después debemos instalar el siguiente paquete:
```
apt-get install build-essential
```

### 2.2. Grupos de trabajo

Lo primero que realizaremos para la configuración del sistema es la creación de los dos grupos de usuarios requeridos (CLIENTES y TECNICOS)
Para añadirlos lo hacemos con la siguiente orden:
```
groupadd CLIENTES
groupadd TECNICOS
```
Si queremos ver el id de los usuarios que se encuentran en nuestro sistema podemos usar la siguiente orden:
```
cat /etc/group | awk -F ":" '{ print $1,$3 }'
```
La salida que obtenemos es la siguiente:

![img05](assets/img05.png?raw=true "img05")

También debemos crear una carpeta para el grupo de técnicos en la cual solo puedan acceder ellos por lo que la crearemos en el directorio */mnt/home/manuales*. Cabe destacar que */mnt/home* en el momento de esta explicación no está creado ya que será la partición donde guardaremos los usuarios, sin embargo, en [esta]() sección podemos ver como instalarla.
Para la creación de esta carpeta realizamos los siguientes comandos:

```
mkdir /mnt/home/manuales
chown root:1004 /mnt/home/manuales
```
Donde pone 1004 se debe poner el número que nos devuelve el comando que hemos explicado anteriormente. El comando *chown* sirve para especificar el o los propietarios de un archivo o carpeta.
### 2.3. Reporte del login del administrador
Para la realización de este apartado haremos uso de la carpeta */etc/profile.d/* esta carpeta contiene con una serie de scripts que se ejecutan al iniciar sesión. Encontramos un problema ya que al guardar en esta carpeta nuestro código de perl para enviar un correo al administrador, no se ejecutaba el programa por lo que creamos un fichero *.sh* que ejecutara el *.pl*. El script *.sh* es el siguiente:

```perl
#!/usr/bin/bash
`perl /etc/profile.d/report_root_login.pl`;
```
El script *.pl* es el siguiente:
```perl
#!/usr/bin/perl
use strict;
use warnings;

use Mail::Sender;
use Email::Send::SMTP::Gmail;


my $destination='xamo1998@gmail.com';
my ($mail,$error)=Email::Send::SMTP::Gmail->new( -smtp=>'smtp.gmail.com',
                                                 -login=>'xamo1998@gmail.com',
                                                 -pass=>'XXXXXXXXXXXXXXXXXXX',
                                                 -layer=>'ssl');
print "Session error: $error" unless ($mail!=1);
$mail->send(-to=>$destination,-subject=>'Admin Login', -body=>'The admin just loged in the system! =) ', -attachments=>'');
$mail->bye;
```
Para el correcto funcionamiento del código anterior hemos tenido que instalar a través de CPAN los módulos *Mail::Sender* y *Email::Send::SMTP::Gmail*, para ello tan solo ejecutamos el comando cpan y una vez dentro *install Mail::Sender* y *Email::Send::SMTP::Gmail*.

### 2.4. Copias de seguridad
En este apartado vamos a explicar el método que hemos usado para la realización de las copias de seguridad.
Dicho esto, vamos a explicar como lo hemos hecho, hemos utilizado rsync que es una aplicación libre para sistemas de tipo Unix y Microsoft Windows que ofrece transmisión eficiente de datos incrementales, que opera también con datos comprimidos y cifrados.
Primero mostraremos el fichero que realiza las copias de seguridad:
```perl
#!/usr/bin/perl
use warnings;
use strict;

system('rsync -av /mnt /var/backups/backup_mnt.rsync');
system('rsync -av /etc /var/backups/backup_etc.rsync');
system('rsync -av /home /var/backups/backup_home.rsync');
system('rsync -av /usr/local/sbin /var/backups/backup_usr.rsync');
my $perm=0644;
chmod($perm, "/var/backups/backup_mnt.rsync");
chmod($perm, "/var/backups/backup_etc.rsync");
chmod($perm, "/var/backups/backup_home.rsync");
chmod($perm, "/var/backups/backup_usr.rsync");
```

Este archivo se encuentra en la carpeta _/usr/local/sbin/backups.pl_ y como vemos nos genera una copia de seguridad para las carpetas que nos interesa conservar si se pierden:
-	**/mnt/home**:  Aquí se encuentran todos los usuarios que se registran en el sistema.
-	**/etc**: Archivos de configuración para el correcto funcionamiento del servidor
-	**/home**: Para guardar las carpetas del usuario principal y de otros tipos de usuarios que se encuentren en este directorio.
-	**/usr/local/sbin**: En esta carpeta guardamos los scripts que se ejecutan con el cron.

Si ejecutamos el archivo podemos ver las copias de seguridad que nos ha generado:

![img06](assets/img06.png?raw=true "img06")

Si vemos el tamaño de estos ficheros con el comando *du* vemos que el más grande es el home ya que tenemos muchas cosas descargadas:

![img07](assets/img07.png?raw=true "img07")

Tras haber hecho esto, vamos a ver como hemos hecho las copias remotas, las cuales enviamos por Dropbox utilizando el siguiente código.
### 2.5. Copias de seguridad remotas

Hemos escrito un script el cual permite al administrador mandar sus copias de seguridad a la nube, en este caso a Dropbox, para ello, debemos implementar una serie de cosas:
Primero entramos en Dropbox developers, iniciamos sesión y creamos una aplicación:

![img08](assets/img08.png?raw=true "img08")

Después nos pide 3 datos:

![img09](assets/img09.png?raw=true "img09")

El código es el siguiente:
```perl
use WebService::Dropbox;

my $dropbox = WebService::Dropbox->new({
    key => '1mrpx4in244hy2h', # App Key
    secret => 'cm20j76v7xfwnyf' # App Secret
});
# Authorization
if ($access_token) {
    $dropbox->access_token($access_token);
} else {
    my $url = $dropbox->authorize;

    print "Please Access URL and press Enter: $url\n";
    print "Please Input Code: ";

    chomp( my $code = <STDIN> );

    unless ($dropbox->token($code)) {
        die $dropbox->error;
    }

	    print "Successfully authorized.\nYour AccessToken: ", $dropbox->access_token, "\n";
}

my $info = $dropbox->get_current_account or die $dropbox->error;
 my $to_compress="/var/backups/backup_mnt.rsync /var/backups/backup_usr.rsync /var/backups/backup_etc.rsync";
 my $compressed="/var/backups/backup_mnt.zip";
system("zip -r $compressed $to_compress");
# upload
# https://www.dropbox.com/developers/documentation/http/documentation#files-upload
my $fh_upload = IO::File->new("/var/backups/backup_mnt.zip");
$dropbox->upload('/make_test_folder/backup.zip', $fh_upload) or die $dropbox->error;
$fh_upload->close;
unlink $compressed;
```
Veamos un ejemplo, todos los *.rsync* están dentro de */var/backups/* por lo que los comprimiremos en un *.zip* y los enviaremos a la cuenta del administrador.
Al ejecutar nos proporciona un link el cual al ponerlo en el navegador nos da un código para poder subir los archivos:

![img10](assets/img10.png?raw=true "img10")

Si introducimos el link en el navegador nos aparecerá una ventana como esta:

![img11](assets/img11.png?raw=true "img11")

Le damos a continuar y nos mostrará un código de verificación el cual debemos copiar en el script que estábamos ejecutando anteriormente:

![img12](assets/img12.png?raw=true "img12")

Al copiar el código y dar enter se creará el fichero zip y al acabar se enviará a Dropbox como podemos ver en las siguientes imágenes:

![img13](assets/img13.png?raw=true "img13")

![img14](assets/img14.png?raw=true "img14")

![img15](assets/img15.png?raw=true "img15")

Otra opción para las copias de seguridad remotas es mediante rsync y ssh, dejamos el código para realizarlo con este método:
```perl
#!/usr/bin/perl

use warnings;
use strict;

system('rsync -av /mnt/home backup_mnt.rysnc');
system('rsync -av /etc backup_etc.rysnc');
system('rsync -av /var backup_var.rysnc');
system('rsync -av /usr/local/sbin backup_usr.rysnc');

system('rsync -avz -P -e ssh /mnt/home/backup_mnt.rysnc root@172.20.1.58:/home/backups');
system('rsync -avz -P -e ssh /etc/backup_etc.rysnc root@172.20.1.58:/home/backups');
system('rsync -avz -P -e ssh /var/backup_var.rysnc root@172.20.1.58:/home/backups');
system('rsync -avz -P -e ssh /usr/local/sbin/backup_usr.rysnc root@172.20.1.58:/home/backups');
```
### 2.6. Tripwire

Para la monitorización local hemos usado Tripwire el cual, al ejecutarlo nos proporciona una gran cantidad de información muy útil para el administrador. Para instalar tripwire debemos realizar los siguientes pasos:
Instalamos tripwire con la siguiente orden:
```
apt-get install tripwire
```
lo configuramos como sitio de internet:

![img 16](assets/img16.png?raw=true "img16")

Configuramos nuestro dominio:

![img 17](assets/img17.png?raw=true "img17")

Damos a Si hasta que nos pida una contraseña y la instalación finalizará.
Una vez instalado, es necesario inicializar el sistema de la base de datos con el siguiente comando:
```
tripwire --init
```
Antes de editar la configuración de tripwire, debemos realizar el siguiente comando:
```
sh -c "tripwire --check | grep Filename > no-directory.txt"
```
En este paso debemos ir al directorio de configuración de tripwire y editar el archivo de configuración *rwpool.txt*

![img 18](assets/img18.png?raw=true "img18")

Comentamos la línea del *rc.boot*.

![img 19](assets/img19.png?raw=true "img19")

Comentamos las dos líneas dadas en la imagen.

![img 20](assets/img20.png?raw=true "img20")

Comentamos todas las líneas de la imagen.

![img 21](assets/img21.png?raw=true "img21")

Comentamos y escribimos todas las líneas que vemos en la imagen.

Una vez hechos estos pasos, ejecutamos el siguiente comando:
```
tripwire –update-policy –secure-mode low /etc/tripwire/twpol.txt
```
Para regenerar el archivo de configuración de tripwire ejecutaremos las siguiente línea:
```
twadmin -m P /etc/tripwire/twpol.txt
```
Una vez hayamos hecho todo lo anterior tripwire estará funcionando correctamente.

Para ello hemos realizado el siguiente script que se ejecutará cada día por la noche:
```perl
#!/usr/bin/perl
use strict;
use warnings;

use Mail::Sender;
use Email::Send::SMTP::Gmail;

system('tripwire --check >datos.txt');
my $destination='xamo1998@gmail.com';
my ($mail,$error)=Email::Send::SMTP::Gmail->new( -smtp=>'smtp.gmail.com',
                                                 -login=>'xamo1998@gmail.com',
                                                 -pass=>'XXXXXXXXXXXXXXXXXXX',
                                                 -layer=>'ssl');
print "Session error: $error" unless ($mail!=1);
$mail->send(-to=>$destination,-subject=>'Security report', -body=>'Here is your daily report!', -attachments=>'/usr/local/sbin/datos.txt');
$mail->bye;
unlink 'datos.txt';
```
Al ejecutar el código si vamos a nuestro correo podremos ver como se ha enviado correctamente:

![img 22](assets/img22.png?raw=true "img22")

### 2.7. Ficheros CRON

Aquí explicaremos todos los cron que tenemos en el servidor, para añadir un script al cron tenemos varias opciones, una de ellas es mediante el comando *crontab -e*, otra es modificando el archivo */etc/crontab*.

Mostraremos una captura con los scripts que tenemos en el cron y cuál es su funcionamiento:

![img 23](assets/img23.png?raw=true "img23")

- **check_new_user.pl**: Script que se ejecuta cada 1 minuto y busca en la base de datos de usuarios verificados todos los usuarios y uno a uno los borra de esa base de datos y los mete en la base de datos de usuarios finales, también crea el usuario en Linux
- **delete_users.pl**: Busca en la base de datos de users_to_delete y por cada usuario que haya en esa tabla lo elimina de Linux.
- **change_password.pl**: Busca en la base de datos de users_to_change y por cada usuario que haya en esa tabla lo elimina de Linux y vuelve a crearlo con los nuevos datos.
- **security.pl**: Realiza un check de todo el sistema y le manda la salida al correo del administrador.
- **backups.pl**: Realiza las copias de seguridad.
 

### 2.8. Particiones y cuotas

Los usuarios deben tener asignadas unas cuotas por lo que hemos optado por crear un sistema de fichero donde guardar los */home* de los usuarios y aplicar ahí las cuotas. Para ello debemos realizar los siguientes pasos.
#### 2.8.1 Sistema de ficheros /mnt/home

Primero debemos crear un sistema de ficheros en una carpeta, por ejemplo */home/user/SistemaFich*, para hacer esto realizamos la siguiente orden:
```
dd if=/dev/zero of=/home/hector/SistemaFich count=10240 bs=10240
```
Esta orden nos creara un archivo de aproximadamente 100 Mb lleno de ceros. El siguiente paso es dar formato a este archivo, en nuestro caso hemos elegido ext4 por lo que la orden sería la siguiente:
```
mkfs.ext4 /home/hector/SistemaFich
```
El siguiente paso es montar el sistema de ficheros en el directorio que deseemos, en nuestro caso */mnt/home* por lo que las órdenes a utilizar serían:
```
mkdir /mnt/home
mount -o loop /home/hector/SistemaFich /mnt/home
```
Añadimos una línea al fichero */etc/fstab* el cual se encarga de cargar las particiones del sistema cuando se arranca, para ello escribimos la siguiente línea, con cuidado ya que cada campo se debe separar con un tabulador:
```
/home/hector/SistemaFich /mnt/home ext4 defaults,usrquota 0 0
```
Una vez hecho esto realizamos la siguiente orden:
```
mount -a
```
La partición estará configurada correctamente, si queremos usarla debemos reiniciar el sistema con la orden *reboot*.

#### 2.8.2 Aplicar cuotas

Para aplicar las cuotas al sistema de ficheros debemos seguir los siguientes pasos, primero escribimos la siguiente línea:
```
mount -o remount /mnt/home
```
Una vez hecho esto realizamos las siguientes ordenes:
```
quotacheck -cugm mnt/home
quotaon -ugv /mnt/home/
```
Con esto ya tendríamos las cuotas activadas en */mnt/home* para poder ver un resumen de las quotas en ese directorio escribimos la siguiente orden:
```
repquota /mnt/home
```
Obtenemos una salida como esta:

![img 24](assets/img24.png?raw=true "img24")

Para que cada usuario tenga una cuota en concreto lo veremos más adelante en este informe, en concreto en [esta]() sección:
 

### 2.9. Configurar CGI

Para la comunicación entre el servidor y las páginas web hemos usado CGI, en este apartado vamos a ver como configurarlo para la correcta ejecución de los ficheros .pl.
NOTA: Este paso se debe realizar **después** de la [instalación de apache]()  pero por motivos de presentación en esta memoria lo haremos antes.
Primero debemos activar cgi, para ello realizamos los siguientes comandos:
```apache
a2dismod mpm_event
a2enmod mpm_prefork
a2enmod cgi
```
Después reiniciamos apache con la siguiente orden:
```
systemctl restart apache2
```
Ahora debemos configurar el fichero */etc/apache2/conf-available/cgi-enabled* y copiar lo siguiente:
```
<Directory "/var/www/html/cgi-enabled">
           Options +ExecCGI
           AddHandler cgi-script .cgi .pl .py
</Directory>
```
Después activamos la configuración y reiniciamos apache con las siguientes instrucciones:
```
sudo a2enconf cgi-enabled
sudo service apache2 restart
```
Una vez hecho esto podremos usar ficheros perl para la ejecución de tareas junto con apache.

### 2.10. Ficheros log
En nuestra práctica utilizamos un fichero log que almacena la hora y el tipo de acceso cada vez que un usuario intenta hacer login en nuestro servidor.
No hemos utilizado ningún tipo de comando ya que desde perl nos ha parecido más fácil abrir un fichero y volcar los datos añadiéndolos al final.

## 3. Descripción básica de los servidores

En este apartado veremos cómo hemos instalado y configurado todos los servidores que usamos en nuestro servidor.
### 3.1. SSH
Primero debemos instalar SSH, para ello escribimos:
```
apt-get install ssh
```
Después debemos cambiar la configuración del ssh que se encuentra en */etc/ssh/sshd_config*, debemos escribir las siguientes líneas:
```
Port 1060
Protocol 2
LoginGraceTime 2m
PermitRootLogin no
MaxStartups 5
```
Una vez configurado ssh tan solo tenemos que reiniciar el servicio de la siguiente manera:
```
systemctl restart ssh
```
 

### 3.2. Apache2
En este apartado veremos cómo instalar y configurar Apache.
### 3.3. Introducción
El servidor HTTP Apache es un servidor web HTTP de código abierto, para plataformas Unix (BSD, GNU/Linux, etc.), Microsoft Windows, Macintosh y otras. Es una de las herramientas más usadas para la gestión de servidores que requieren HTTP.
### 3.4. Instalación Apache2
A continuación, procedemos a ver los pasos seguidos en la instalación y configuración de apache. Lo primero de todo antes de instalar nada, siempre es actualizar el sistema:
Una vez actualizado, instalamos el paquete de apache:
```
apt-get install apache2 apache2-doc apache2-utils
```
La salida que obtenemos es la siguiente:

![img 25](assets/img25.png?raw=true "img25")

Podemos destacar que los paquetes para apache tan solo ocupan 30.9 MB.
Si ahora abrimos nuestro navegador y escribimos en la url: *localhost* obtenemos la siguiente página web:

![img 26](assets/img26.png?raw=true "img26")

Como hemos visto en el punto anterior si escribimos localhost en la url del navegador nos devuelve la página web por defecto, también podemos acceder a esta página mediante la ip de nuestro servidor, para obtener la ip nos basta con usar la orden *ip addr* y obtendremos una salida como esta:

![img 27](assets/img27.png?raw=true "img27")

Como vemos, esta orden nos devuelve la ip privada, al igual que con *localhost*, podemos usar la ip. Si queremos acceder a nuestro servidor por un nombre de dominio, por ejemplo, dominio.com debemos modificar el fichero */etc/hosts* para que al intentar resolver el nombre del dominio no sea necesario hacer una petición de DNS.

El archivo, debe quedar así:

![img 28](assets/img28.png?raw=true "img28")

A la izquierda debemos poner la dirección ip local (127.0.0.1) y a la derecha el nombre de dominio que le asociamos a dicha ip.

Por último, para que nuestro dominio este correctamente configurado debemos modificar el fichero: */etc/apache/sites-availabl/000-default.conf*, y escribir lo siguiente:
```
ServerName adsysshop.com:80
ServerAlias www.adsysshop.com
ServerAdmin webmaster@adsysshop.com
DocumentRoot /var/www/html
```
El siguiente paso es editar el fichero de configuración de Apache:
```
pico /etc/apache/apache.conf
```
Insertamos las siguientes líneas de código:
```
<IfModule mpm_prefork_module>
    StartServers 5
    MinSpareServers 5
    MaxSpareServers 10
    MaxClients 100
    MaxRequestsPerChild 0
</IfModule>
```

![img 29](assets/img29.png?raw=true "img29")

El significado de los campos es el siguiente:
-	**StartServers**: Número de procesos que se ejecutan al iniciar Apache.
-	**MinSpareServers**: Mínima cantidad de procesos que se mantienen en espera.
-	**MaxSpareServers**: Cantidad máxima de procesos en espera
-	**MaxClients**: Número máximo de clientes que se pueden ejecutar
-	**MaxRequestsPerChild**: Número de peticiones que atiende cada hilo de ejecución

Por último, tenemos que reiniciar el servicio para actualizar la configuración:
```
systemctl restart apache2
```
